package parser

import (
	"fmt"
	"go/ast"
	"go/parser"
	"io/ioutil"
	"strconv"
	"strings"
	// "go/printer"
	"go/token"
	// 	"go/types"
	// "go/importer"

	"github.com/kataras/iris-cli/utils"
)

type AssetDir struct {
	Dir             string
	ShouldGenerated bool
}

type Result struct {
	AssetDirs []AssetDir
	Commands  []string
}

const dirOptionsDeclName = "iris.DirOptions"

func Parse(src interface{}) (res Result, err error) {
	var (
		input    []byte
		filename string
	)

	if s, ok := src.(string); ok {
		if utils.Exists(s) {
			// it's a file or dir.
			if utils.IsDir(s) {
				// TODO: parser.ParseDir if ever required.
				err = fmt.Errorf("path <%s> is not a go file", src)
				return
			}

			filename = s
			input, err = ioutil.ReadFile(s)
			if err != nil {
				return
			}
		} else {
			input = []byte(s)
		}
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, input, parser.ParseComments)
	if err != nil {
		return res, err
	}

	for _, comment := range node.Comments {
		commentText := strings.TrimSpace(strings.TrimSuffix(comment.Text(), "\n"))
		commands := strings.Split(commentText, "$")
		for _, command := range commands {
			if command == "" {
				continue
			}
			res.Commands = append(res.Commands, strings.TrimSpace(command))
		}
	}

	ast.Inspect(node, func(n ast.Node) bool {
		if expr, ok := n.(*ast.ExprStmt); ok {
			if c, ok := expr.X.(*ast.CallExpr); ok {
				if cSelector, ok := c.Fun.(*ast.SelectorExpr); ok {
					if cSelector.Sel.Name != "HandleDir" {
						return true // we only care for ".HandleDir"
					}
				}

				isDirOptsGoBindata := false
				if nargs := len(c.Args); nargs >= 2 {
					if nargs == 3 {
						// contains the last optional iris.DirOptions argument.
						if dirOpts, ok := c.Args[2].(*ast.CompositeLit); ok {
							if dirOptSel, ok := dirOpts.Type.(*ast.SelectorExpr); ok {
								pkgF := ""
								if s, ok := dirOptSel.X.(*ast.Ident); ok {
									pkgF = s.Name
								}

								if pkgF+"."+dirOptSel.Sel.Name == dirOptionsDeclName {
									// should be iris.DirOptions, no other package name.
									for _, eltExpr := range dirOpts.Elts {
										if kvExpr, ok := eltExpr.(*ast.KeyValueExpr); ok {
											if key, ok := kvExpr.Key.(*ast.Ident); ok {
												if key.Name == "Asset" {
													if value, ok := kvExpr.Value.(*ast.Ident); ok {
														if value.Name == "Asset" {
															// iris.DirOptions{ Asset: Asset...}
															// Probably, should be generated by go-bindata.
															isDirOptsGoBindata = true
														}
													}
												}
											}

										}
									}
								}

							}
						}
					}

					assetsDir := ""

					// now get the previous arg[1]; first is the request path and second(!) is the go-bindata target path we want to extract.
					switch arg := c.Args[1].(type) {
					case *ast.BasicLit:
						assetsDir = arg.Value
						// cmd.Printf("go-bindata target is (basic lit): %s\n",  assetsDir)
					case *ast.Ident:
						searchVar := arg.Name
						for _, decl := range node.Decls {
							if gen, ok := decl.(*ast.GenDecl); ok {
								for _, spec := range gen.Specs {
									if spec, ok := spec.(*ast.ValueSpec); ok {
										for _, id := range spec.Names {
											if searchVar == id.Name {
												// found the varialbe, get its value.
												assetsDir = id.Obj.Decl.(*ast.ValueSpec).Values[0].(*ast.BasicLit).Value
												// cmd.Printf("go-bindata target is (variable): %s\n", assetsDir)
											}
										}
									}
								}

							}
						}
					}

					s, err := strconv.Unquote(assetsDir)
					if err == nil {
						assetsDir = s
					}
					res.AssetDirs = append(res.AssetDirs, AssetDir{Dir: assetsDir, ShouldGenerated: isDirOptsGoBindata})

				}
			}
		}
		return true
	})

	return res, nil
}
